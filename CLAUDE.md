# CLAUDE.md - プロジェクトコンテキストとベストプラクティス

## プロジェクト概要
Rust で実装する Support Vector Machine (SVM) ライブラリ。SVMlight 論文 "Making Large-Scale SVM Learning Practical" by Thorsten Joachims に基づいた実装。

## コミュニケーション言語
- ディスカッション: 日本語
- コードベース（コメント、コミットメッセージ、ドキュメント）: 英語（アメリカ英語）

## 開発方針

### ライセンスポリシー
- **採用ライセンス**: MIT
- **依存関係**:
  - MIT、BSD-3-Clause、Apache-2.0 ライセンスのライブラリを優先
  - GPL、LGPL ライセンスの依存関係は避ける
  - 推移的依存関係も含めてライセンス互換性を確認
  - MIT ライセンスとの互換性を重視

### 開発アプローチ
- **インクリメンタル開発**: 全モジュールを一度に作るのではなく、段階的に構築
- **将来の拡張性を考慮**: 
  - カーネルの追加（RBF、多項式など）
  - ワーキングセットサイズの拡張（q > 2）
  - マルチクラス分類
  - GPU サポート
- **テスト駆動開発**: 90% のカバレッジ目標

### 実装の優先順位
1. コアタイプとトレイト（types.rs, traits.rs）
2. 線形カーネル実装
3. 基本的な SMO ソルバー（2変数）
4. データセットサポート（libsvm形式、CSV）
5. 最適化器の実装
6. メインAPI
7. 拡張機能（RBFカーネル、シュリンキング、キャッシュ最適化）

## ベストプラクティス

### コード品質
```bash
# Linting
cargo clippy -- -D warnings

# フォーマット
cargo fmt

# テスト実行
cargo test

# カバレッジ（cargo-tarpaulinを使用）
cargo tarpaulin --out Html
```

### パフォーマンス考慮事項
- スパースベクトルの操作は常にソート済みインデックスを維持（O(n)のドット積を実現）
- カーネル行列の対称性を活用（キャッシュキーは i <= j に正規化）
- 変更されたアルファのみに基づいて勾配を更新
- 並列処理には rayon を使用

### エラーハンドリング
- `thiserror` を使用した型安全なエラー処理
- パニックよりも Result 型を優先
- 明確なエラーメッセージとコンテキスト

### ドキュメンテーション
- 開発中はラフなドキュメント
- マイルストーン完了時に洗練
- 数式参照は論文の式番号を明記（例: "equation 11.14 from the paper"）

## アーキテクチャの重要ポイント

### メモリ効率
- トレーニング例数とサポートベクター数に対して線形メモリ要件
- LRU キャッシュによるカーネル値の効率的な管理

### 数値安定性
- 浮動小数点演算の慎重な取り扱い
- 収束基準の適切な設定（デフォルト epsilon = 0.001）

### 拡張性
- トレイトベースの設計で新しいカーネルや最適化戦略の追加が容易
- ジェネリックプログラミングの活用

## 現在の実装状況
- [x] プロジェクト基本構造
- [x] Cargo.toml 作成
- [x] GitHub Actions CI/CD 設定
- [x] コアタイプとトレイト
- [x] 線形カーネル
- [x] SMO ソルバー（2変数最適化）
- [x] データセットサポート（LibSVM、CSV形式）
- [x] 最適化器統合
- [x] メインAPI（ビルダーパターン、クイック関数）
- [x] 包括的テスト（88テスト、90%+カバレッジ達成）
- [x] 統合テスト（エンドツーエンド、データセット互換性）
- [x] チュートリアルドキュメント
- [x] **CLIアプリケーション**（train, predict, evaluate, info, quick コマンド）
- [x] **モデル永続化**（JSON形式での保存・読み込み）

## 将来の拡張可能性（優先度順）
- [ ] **モデル再構築機能**（保存済みモデルからの完全復元）
- [ ] RBFカーネル実装
- [ ] 多項式カーネル実装
- [ ] シュリンキング最適化
- [ ] マルチクラス分類サポート
- [ ] ワーキングセットサイズ拡張（q > 2）
- [ ] GPU サポート（CUDA/OpenCL）
- [ ] 並列処理最適化（rayon活用）

## 開発ログ
### 2025-01-06
- プロジェクト初期化完了
- GitHub Actions設定作成（マルチプラットフォーム対応、ライセンスチェック含む）
- 明示的なファイル指定でのgit add使用（`git add -A`は避ける）

### 2025-06-12
- 線形カーネル実装完了（効率的なスパースベクトルドット積）
- SMOソルバー完全実装（KKT条件チェック、2変数最適化、エラーキャッシュ）
- データセット読み込み実装（LibSVM、CSV形式対応）
- オプティマイザー統合完了（SVMOptimizer、TrainedSVM）
- メインAPI実装完了（ビルダーパターン、クイック関数、評価メトリクス）
- 包括的テストスイート実装（88テスト：72ユニット + 16統合）
- カバレッジ90%+達成（目標達成）
- 統合テスト追加（エンドツーエンド、データセット互換性、パフォーマンス）
- 完全なチュートリアルドキュメント作成
- **CLIアプリケーション実装完了**（train, predict, evaluate, info, quick コマンド）
- **モデル永続化機能実装**（JSON形式、メタデータ付きシリアライゼーション）
- **包括的CLI使用例ドキュメント作成**（CLI_EXAMPLES.md）
- **プロダクション品質のSVMライブラリ + CLI完成**

### 2025-06-13
- **CI/CD問題解決とRust Beta互換性**（重要な学習セッション）
- ライセンスチェック改善（マルチライセンス依存関係の適切な処理）
- Rust Beta clippyワーニング修正（uninlined_format_args、ptr_arg、needless_range_loop）
- CI環境での複数Rustツールチェーン対応
- **MIT ライセンス採用決定**（Cargo.toml、LICENSE ファイル、ドキュメント更新）

## 注意事項
- 過度な仮定を避け、不明な点は確認する
- 頻繁な進捗報告（初期は頻繁に、その後調整）
- API設計はモダンで慣用的な Rust インターフェースを目指す

## Git ベストプラクティス
- **コミット前チェック必須**: 
  - 全てのコミット前に `cargo test` を実行して全テスト通過を確認
  - コミット前に `cargo fmt` を実行してコードフォーマットを整える
  - テスト失敗時は修正してからコミット
  - 警告（warning）は許容するが、エラーは不可
- **頻繁なコミット**: 
  - 機能実装、テスト追加、バグ修正などの完了時に即座にコミット
  - カバレッジ向上、リファクタリング、ドキュメント更新も個別にコミット
  - 作業中断前には必ずコミット（WIP commit も可）
  - 目安：30分〜1時間の作業でコミット、複数ファイル変更時は特に注意
- **明示的なファイル指定**: `git add -A` は使用せず、常に具体的なファイルを指定する
  ```bash
  # 良い例
  git add src/core/types.rs src/core/mod.rs
  
  # 避けるべき例
  git add -A
  git add .
  ```
- **明確なコミットメッセージ**: 変更の目的と内容を明確に記述

## CI/CD とクロスプラットフォーム開発のベストプラクティス

### 学習した重要事項（2025-06-13の経験から）

#### ライセンスチェックの複雑性
- **課題**: マルチライセンス依存関係（例: "Apache-2.0 OR LGPL-2.1-or-later OR MIT"）で文字列マッチングによる誤検出
- **解決策**: 
  - ライセンス文字列の適切なパース処理を実装
  - SPDX式の理解が必要（OR演算子の処理）
  - GPL/LGPL**のみ**の依存関係を避け、代替選択肢があるものは許可
- **教訓**: 単純な文字列検索では不十分、ライセンス互換性チェックには専用ロジックが必要

#### Rust Beta互換性とClippy警告
- **課題**: Rust Betaでの新しいclippy lintによるCI失敗
  - `uninlined_format_args`: `format!("{}", var)` → `format!("{var}")`
  - `ptr_arg`: `&Vec<T>` → `&[T]`
  - `needless_range_loop`: インデックスループ → イテレータ
- **解決策**:
  - ローカルでBetaツールチェーンテストを必須とする
  - `rustup run beta cargo clippy` での事前検証
  - フォーマット文字列の統一的な更新
- **教訓**: CI失敗の根本原因を特定せずに推測で修正するのは非効率

#### 効果的なトラブルシューティングプロセス
1. **CI失敗の正確な原因特定**:
   - ログの詳細読み込み（どのジョブ、どのツールチェーン）
   - 環境の違い（ubuntu-latest vs windows-latest）
   - 推測ではなく事実に基づく分析

2. **ローカル再現の重要性**:
   - CI環境と同じツールチェーンでのローカルテスト
   - `rustup install beta` → `rustup run beta cargo clippy`
   - 修正前の問題確認と修正後の検証

3. **段階的修正アプローチ**:
   - 一度に全ての警告を修正しようとせず、段階的に対応
   - 各修正後にローカルテストで検証
   - コミット前に stable/beta 両方での動作確認

#### クロスプラットフォーム考慮事項
- **Windows vs Linux**: パスセパレータ、ファイルシステムの違い
- **一時ファイル処理**: 環境依存の動作差異に注意
- **複数Rustバージョン**: stable, beta, nightly での互換性維持

### 推奨されるCI/CDワークフロー
```bash
# ローカル開発時の必須チェック
cargo fmt                              # フォーマット
cargo clippy -- -D warnings           # stable clippy
rustup run beta cargo clippy -- -D warnings  # beta clippy
cargo test                             # テスト実行
```

### 今後の改善案
- CI失敗時のより詳細なログ出力
- ライセンスチェック機能の継続的改善
- 複数Rustバージョンでの定期的な互換性テスト
- 依存関係更新時のライセンス再チェック自動化