# CLAUDE.md - プロジェクトコンテキストとベストプラクティス

## プロジェクト概要
Rust で実装する Support Vector Machine (SVM) ライブラリ。SVMlight 論文 "Making Large-Scale SVM Learning Practical" by Thorsten Joachims に基づいた実装。

## コミュニケーション言語
- ディスカッション: 日本語
- コードベース（コメント、コミットメッセージ、ドキュメント）: 英語（アメリカ英語）

## 開発方針

### ライセンスポリシー
- **目標ライセンス**: MIT/BSD-3-Clause
- **依存関係**:
  - MIT、BSD-3-Clause、Apache-2.0 ライセンスのライブラリを優先
  - GPL、LGPL ライセンスの依存関係は避ける
  - 推移的依存関係も含めてライセンス互換性を確認

### 開発アプローチ
- **インクリメンタル開発**: 全モジュールを一度に作るのではなく、段階的に構築
- **将来の拡張性を考慮**: 
  - カーネルの追加（RBF、多項式など）
  - ワーキングセットサイズの拡張（q > 2）
  - マルチクラス分類
  - GPU サポート
- **テスト駆動開発**: 90% のカバレッジ目標

### 実装の優先順位
1. コアタイプとトレイト（types.rs, traits.rs）
2. 線形カーネル実装
3. 基本的な SMO ソルバー（2変数）
4. データセットサポート（libsvm形式、CSV）
5. 最適化器の実装
6. メインAPI
7. 拡張機能（RBFカーネル、シュリンキング、キャッシュ最適化）

## ベストプラクティス

### コード品質
```bash
# Linting
cargo clippy -- -D warnings

# フォーマット
cargo fmt

# テスト実行
cargo test

# カバレッジ（cargo-tarpaulinを使用）
cargo tarpaulin --out Html
```

### パフォーマンス考慮事項
- スパースベクトルの操作は常にソート済みインデックスを維持（O(n)のドット積を実現）
- カーネル行列の対称性を活用（キャッシュキーは i <= j に正規化）
- 変更されたアルファのみに基づいて勾配を更新
- 並列処理には rayon を使用

### エラーハンドリング
- `thiserror` を使用した型安全なエラー処理
- パニックよりも Result 型を優先
- 明確なエラーメッセージとコンテキスト

### ドキュメンテーション
- 開発中はラフなドキュメント
- マイルストーン完了時に洗練
- 数式参照は論文の式番号を明記（例: "equation 11.14 from the paper"）

## アーキテクチャの重要ポイント

### メモリ効率
- トレーニング例数とサポートベクター数に対して線形メモリ要件
- LRU キャッシュによるカーネル値の効率的な管理

### 数値安定性
- 浮動小数点演算の慎重な取り扱い
- 収束基準の適切な設定（デフォルト epsilon = 0.001）

### 拡張性
- トレイトベースの設計で新しいカーネルや最適化戦略の追加が容易
- ジェネリックプログラミングの活用

## 現在の実装状況
- [x] プロジェクト基本構造
- [x] Cargo.toml 作成
- [x] GitHub Actions CI/CD 設定
- [x] コアタイプとトレイト
- [x] 線形カーネル
- [x] SMO ソルバー（2変数最適化）
- [x] データセットサポート（LibSVM、CSV形式）
- [x] 最適化器統合
- [x] メインAPI（ビルダーパターン、クイック関数）
- [x] 包括的テスト（88テスト、90%+カバレッジ達成）
- [x] 統合テスト（エンドツーエンド、データセット互換性）
- [x] チュートリアルドキュメント
- [x] **CLIアプリケーション**（train, predict, evaluate, info, quick コマンド）
- [x] **モデル永続化**（JSON形式での保存・読み込み）

## 将来の拡張可能性（優先度順）
- [ ] **モデル再構築機能**（保存済みモデルからの完全復元）
- [ ] RBFカーネル実装
- [ ] 多項式カーネル実装
- [ ] シュリンキング最適化
- [ ] マルチクラス分類サポート
- [ ] ワーキングセットサイズ拡張（q > 2）
- [ ] GPU サポート（CUDA/OpenCL）
- [ ] 並列処理最適化（rayon活用）

## 開発ログ
### 2025-01-06
- プロジェクト初期化完了
- GitHub Actions設定作成（マルチプラットフォーム対応、ライセンスチェック含む）
- 明示的なファイル指定でのgit add使用（`git add -A`は避ける）

### 2025-06-12
- 線形カーネル実装完了（効率的なスパースベクトルドット積）
- SMOソルバー完全実装（KKT条件チェック、2変数最適化、エラーキャッシュ）
- データセット読み込み実装（LibSVM、CSV形式対応）
- オプティマイザー統合完了（SVMOptimizer、TrainedSVM）
- メインAPI実装完了（ビルダーパターン、クイック関数、評価メトリクス）
- 包括的テストスイート実装（88テスト：72ユニット + 16統合）
- カバレッジ90%+達成（目標達成）
- 統合テスト追加（エンドツーエンド、データセット互換性、パフォーマンス）
- 完全なチュートリアルドキュメント作成
- **CLIアプリケーション実装完了**（train, predict, evaluate, info, quick コマンド）
- **モデル永続化機能実装**（JSON形式、メタデータ付きシリアライゼーション）
- **包括的CLI使用例ドキュメント作成**（CLI_EXAMPLES.md）
- **プロダクション品質のSVMライブラリ + CLI完成**

## 注意事項
- 過度な仮定を避け、不明な点は確認する
- 頻繁な進捗報告（初期は頻繁に、その後調整）
- API設計はモダンで慣用的な Rust インターフェースを目指す

## Git ベストプラクティス
- **コミット前チェック必須**: 
  - 全てのコミット前に `cargo test` を実行して全テスト通過を確認
  - コミット前に `cargo fmt` を実行してコードフォーマットを整える
  - テスト失敗時は修正してからコミット
  - 警告（warning）は許容するが、エラーは不可
- **頻繁なコミット**: 
  - 機能実装、テスト追加、バグ修正などの完了時に即座にコミット
  - カバレッジ向上、リファクタリング、ドキュメント更新も個別にコミット
  - 作業中断前には必ずコミット（WIP commit も可）
  - 目安：30分〜1時間の作業でコミット、複数ファイル変更時は特に注意
- **明示的なファイル指定**: `git add -A` は使用せず、常に具体的なファイルを指定する
  ```bash
  # 良い例
  git add src/core/types.rs src/core/mod.rs
  
  # 避けるべき例
  git add -A
  git add .
  ```
- **明確なコミットメッセージ**: 変更の目的と内容を明確に記述